{"version":3,"sources":["/Users/hsunpeiwang/Documents/Projects/iChef/transcharts/packages/chart/src/common/config.ts","/Users/hsunpeiwang/Documents/Projects/iChef/transcharts/packages/chart/src/utils/getInnerGraphDimensionAndMargin.ts","/Users/hsunpeiwang/Documents/Projects/iChef/transcharts/packages/chart/src/hooks/useChartDimensions.ts","/Users/hsunpeiwang/Documents/Projects/iChef/transcharts/packages/chart/src/utils/getAxisProjectedValues.ts","/Users/hsunpeiwang/Documents/Projects/iChef/transcharts/packages/chart/src/hooks/useCartesianEncodings.ts","/Users/hsunpeiwang/Documents/Projects/iChef/transcharts/packages/chart/src/frames/SvgWithAxisFrame.tsx","/Users/hsunpeiwang/Documents/Projects/iChef/transcharts/packages/chart/src/line/LineChart.tsx","/Users/hsunpeiwang/Documents/Projects/iChef/transcharts/packages/chart/src/utils/getBarChartPos.ts","/Users/hsunpeiwang/Documents/Projects/iChef/transcharts/packages/chart/src/bar/BarChart.tsx","/Users/hsunpeiwang/Documents/Projects/iChef/transcharts/packages/chart/src/index.ts"],"names":["DEFAULT_VALS","MARGIN","top","right","bottom","left","DEFAULT_LENGTH","getInnerGraphDimensionAndMargin","dimension","margin","headerDimension","legendDimension","legendOrient","outerWidth","width","outerHeight","height","graphWidth","graphHeight","graphMargin","Object","objectSpread","graphDimension","useChartDimensions","arguments","length","undefined","color","chartRef","useRef","legendRef","titleRef","outerDimension","useContainerDimension","legend","orient","_useMemo","useMemo","getAxisProjectedValues","dataGroups","baseSelector","projectedSelector","getColorString","projections","basePositions","forEach","group","groupIdx","row","baseStrVal","getFormattedStringVal","projectedStrVal","basePos","getScaledVal","projectedPos","push","keys","reduce","accum","projectedVals","column","concat","toConsumableArray","sort","a","b","getLinearDomainFromDataGroup","keyField","valueField","aggreatedMax","aggreatedMin","data","key","val","Math","min","apply","values","max","useCartesianEncodings","theme","x","y","drawFromXAxis","sortedData","baseAxis","getValue","getValByScaleType","scale","getOriginalVal","record","field","rowA","rowB","encodings","filter","encoding","getDataGroupByEncodings","xAxis","axisScale","getXAxisScale","axisLength","domain","yAxis","getYAxisScale","xSelector","getRecordFieldSelector","ySelector","colorScale","getColorScale","colors","defaultColor","category","axisProjectedValues","scalesConfig","rowValSelectors","getString","Wrapper","styled","div","_templateObject","_ref","fontColor","FrameContent","_ref2","showLeftAxis","showBottomAxis","axisInBackground","svgOverlay","children","axisLayer","react_default","createElement","src","xAxisScale","yAxisScale","Fragment","transform","defaultProps","SvgWithAxisFrame","React","forwardRef","_ref3","ref","title","titleDesc","titleAlign","restProps","objectWithoutProperties","globalStyle","useContext","ThemeContext","assign","SvgWithAxisFrame_FrameContent","desc","align","getXPosByIndex","arr","idx","arrIdx","HoveringIndicator","hovering","projectedPoints","circles","map","pointY","cx","cy","r","fill","x1","y1","x2","y2","style","stroke","strokeWidth","DataLine","rows","lineDots","dataRow","index","vx_shape_es","strokeLinecap","strokeLinejoin","LineChart","_useChartDimensions","_useHoverState","useHoverState","clearHovering","hoveredPoint","setHoveredPosAndIndex","_useCartesianEncoding","graphGroup","colorString","LineChart_DataLine","hoverDetectionComponents","rectX","rectWidth","opacity","LineChart_HoveringIndicator","getAccumXCalculator","baseX","positiveX","nonPositiveX","yPos","scaledX","xPos","getAccumYCalculator","baseY","positiveY","nonPositiveY","scaledY","paddingInner","BarChart","_ref2$margin","_ref2$paddingInner","type","xEncoding","yEncoding","scaleConfig","bandScale","linearScale","bandWidth","bandwidth","xOffset","getHoveringRectPos","useCallback","paddingVal","baseVal","getAccumVal","rowIdx","barPos","abs","diffFromBase","BarChart_HoveringIndicator","__webpack_require__","d","__webpack_exports__","LineChart_LineChart","BarChart_BarChart"],"mappings":"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","file":"static/js/docs-chart-settings-data-encodings~docs-chart-settings-legend~docs-chart-settings-title~docs-charts-~20bd6ab0.65602641.js","sourcesContent":["export const DEFAULT_VALS = {\n  MARGIN: {\n    top: 20,\n    right: 20,\n    bottom: 50,\n    left: 55,\n  },\n};\n","import { GraphDimension, Margin, LegendConfig } from '@ichef/transcharts-graph';\n\nconst DEFAULT_LENGTH = 300;\n\n/**\n * Returns the inner width and height of the graph\n * @param dimension - the outer width and height of the graph\n * @param margin - the lengths of top, right, bottom, and left margin\n * @param headerDimension - the width and height of the header box\n * @param legendDimension - the width and height of the legend\n * @param legendOrient - orient of legend\n */\nexport function getInnerGraphDimensionAndMargin(\n  dimension: GraphDimension,\n  margin: Margin,\n  headerDimension: GraphDimension,\n  legendDimension: GraphDimension,\n  legendOrient: LegendConfig['orient'],\n) {\n  const { width: outerWidth, height: outerHeight } = dimension;\n  const { top, right, bottom, left } = margin;\n  let graphWidth = DEFAULT_LENGTH;\n  let graphHeight = DEFAULT_LENGTH;\n  const graphMargin = { ...margin };\n\n  // deal with the legend\n  switch (legendOrient) {\n    case 'left':\n    case 'right': {\n      graphWidth = outerWidth > 0\n        ? outerWidth - left - right - legendDimension.width\n        : DEFAULT_LENGTH;\n      graphHeight = outerHeight > 0 ? outerHeight - top - bottom : DEFAULT_LENGTH;\n      if (legendOrient === 'left') {\n        graphMargin.left += legendDimension.width;\n      }\n      break;\n    }\n    case 'top':\n    case 'bottom': {\n      graphWidth = outerWidth > 0 ? outerWidth - left - right : DEFAULT_LENGTH;\n      graphHeight = outerHeight > 0\n        ? outerHeight - top - bottom - legendDimension.height\n        : DEFAULT_LENGTH;\n      if (legendOrient === 'top') {\n        graphMargin.top += legendDimension.height;\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n\n  // deal with the header box\n  graphMargin.top += headerDimension.height;\n  graphHeight -= headerDimension.height;\n\n  return {\n    graphMargin,\n    graphDimension: {\n      width: graphWidth,\n      height: graphHeight,\n    },\n  };\n}\n","import { useRef, useMemo } from 'react';\nimport {\n  // from common types\n  Margin,\n  GraphDimension,\n  ColorEncoding,\n  // from hooks\n  useContainerDimension,\n} from '@ichef/transcharts-graph';\n\nimport { getInnerGraphDimensionAndMargin } from '../utils/getInnerGraphDimensionAndMargin';\n\n/**\n * Returns a ref to be bind with a container,\n * and it calculates the inner and outer dimension of the graph\n * based on the given margin.\n */\nexport const useChartDimensions = (\n  /** Margin between the inner graph area and the outer svg */\n  margin: Margin = {\n    top: 20,\n    right: 20,\n    bottom: 30,\n    left: 60,\n  },\n  color?: ColorEncoding,\n) => {\n  // compute the outer and inner dimension of the chart\n  const chartRef = useRef<HTMLDivElement>(null);\n  const legendRef = useRef<HTMLDivElement>(null);\n  const titleRef = useRef<HTMLDivElement>(null);\n  const outerDimension: GraphDimension = useContainerDimension(chartRef);\n  const legendDimension = useContainerDimension(legendRef);\n  const headerDimension = useContainerDimension(titleRef);\n  const legendOrient = (color && color.legend && color.legend.orient) || 'right';\n\n  const { graphDimension, graphMargin }  = useMemo(\n    () => {\n      return getInnerGraphDimensionAndMargin(\n        outerDimension,\n        margin,\n        headerDimension,\n        legendDimension,\n        legendOrient,\n      );\n    },\n    [\n      outerDimension,\n      margin,\n      headerDimension,\n      legendDimension,\n      legendOrient,\n    ],\n  );\n\n  return {\n    /** Ref to the chart, which is to be passed in the props of the container */\n    chartRef,\n\n    /** Ref to the header box, which is to be passed in the props of the header box */\n    titleRef,\n\n    /** Ref to the legend, which is to be passed in the props of the legend */\n    legendRef,\n\n    /** Width and height of the outer container */\n    outerDimension,\n\n    /** Width and height of the inner graph (does not contain axes, legend, etc...) */\n    graphDimension,\n\n    /** Margin between the chart container and the inner graph */\n    graphMargin,\n  };\n};\n","import {\n  // from common types\n  FieldSelector,\n} from '@ichef/transcharts-graph';\n\n/**\n * Return the y-values in the `dataGroups` grouped by projected base values.\n * -  Structure of projectedVals: \"projectedVals\":[ { \"index of dataGroup\": \"value\" }, ... ]\n * @example\n * [{\n *  \"basePos\": 0,\n *  \"baseStrVal\": \"0\",\n *  \"projectedVals\": [{\"groupIdx\": 0, \"projectedStrVal\": 9, \"projectedPos\": 18, \"color\": \"#deebf7\"}],\n *  },\n * {\n *  \"basePos\": 109.12812500000001,\n *  \"baseStrVal\": \"2\",\n *  \"projectedVals\": [{\"groupIdx\": 0, \"projectedStrVal\": 3, \"projectedPos\": 6, \"color\": \"#deebf7\"}, ...],\n * }]\n */\nexport function getAxisProjectedValues(\n  /** Data grouped in `useCartesianEncodings()`  */\n  dataGroups: object[][],\n\n  /**\n   * Functions to get value on the base axis,\n   * normally x-axis, if the graph has not been transposed.\n   */\n  baseSelector: FieldSelector,\n\n  /**\n   * Functions to get value on the project axis,\n   * normally y-axis, if the graph has not been transposed.\n   */\n  projectedSelector: FieldSelector,\n\n  /** Functions to get the formatted color string */\n  getColorString: (record: any) => string,\n) {\n  // project by original values on the axis\n  const projections = {};\n  const basePositions = {};\n  dataGroups.forEach((group, groupIdx) => {\n    group.forEach((row) => {\n      const baseStrVal = baseSelector.getFormattedStringVal(row);\n      const projectedStrVal = projectedSelector.getFormattedStringVal(row);\n      const basePos = baseSelector.getScaledVal(row);\n      const projectedPos = projectedSelector.getScaledVal(row);\n      if (!projections[baseStrVal]) {\n        projections[baseStrVal] = [];\n        basePositions[baseStrVal] = basePos;\n      }\n      projections[baseStrVal].push({\n        groupIdx,\n        projectedStrVal,\n        projectedPos,\n        color: getColorString(row),\n      });\n    });\n  });\n\n  // convert the position along the axis, and sort by the converted values\n  const columns = Object.keys(projections).reduce(\n    (accum, baseStrVal: any) => {\n      const projectedVals = projections[baseStrVal];\n      // ensure that we always get the correct type, not a string instead\n      const basePos: number = basePositions[baseStrVal] || 0;\n      const column = {\n        basePos,\n        baseStrVal,\n        projectedVals,\n      };\n\n      return [...accum, column];\n    },\n    []\n  );\n\n  return columns.sort((a, b) => (a.basePos - b.basePos));\n}\n","import { useMemo } from 'react';\nimport values from 'lodash/values';\nimport {\n  // from utils\n  getColorScale,\n  getDataGroupByEncodings,\n  getXAxisScale,\n  getYAxisScale,\n  getRecordFieldSelector,\n  getValByScaleType,\n  // from common types\n  Encoding,\n  AxisEncoding,\n  ColorEncoding,\n  GraphDimension,\n  // from themes\n  Theme,\n  // from TooltipLayer\n  AxisProjectedValue,\n} from '@ichef/transcharts-graph';\n\nimport { getAxisProjectedValues } from '../utils/getAxisProjectedValues';\n\n/**\n * Return [min, max] of a column selected from the grouped data\n */\nfunction getLinearDomainFromDataGroup(\n  dataGroups: object[][],\n  keyField: string,\n  valueField: string,\n) {\n  const aggreatedMax: object = {};\n  const aggreatedMin: object = {};\n  dataGroups.forEach((data: object[]) => {\n    data.forEach((row) => {\n      const key = row[keyField];\n      const val = row[valueField];\n      if (val >= 0) {\n        aggreatedMax[key] = aggreatedMax[key]\n          ? aggreatedMax[key] + val\n          : val;\n      } else {\n        aggreatedMin[key] = aggreatedMin[key]\n          ? aggreatedMin[key] + val\n          : val;\n      }\n    });\n  });\n\n  const min = Math.min(0, ...values(aggreatedMin));\n  const max = Math.max(0, ...values(aggreatedMax));\n\n  return [min, max];\n}\n\n/**\n * It returns calculated groups of data and its value selectors\n * from the given encodings of Cartesian plots.\n */\nexport const useCartesianEncodings = (\n  /** Width and height of the inner graph (does not contain axes, legend, etc...) */\n  graphDimension: GraphDimension,\n\n  /** Theme of the chart, used for the generation of the color scale */\n  theme: Theme,\n\n  /** Array of rows of data */\n  data: object[],\n\n  /** Field and data type of x-axis */\n  x: AxisEncoding,\n\n  /** Field and data type of y-axis */\n  y: AxisEncoding,\n\n  /** Fields and definitions for colors */\n  color?: ColorEncoding,\n\n  /**\n   * Whether the graph is drawn from the x-axis, i.e., vertical graph.\n   * In a transposed (horizontal) graph, you have to set it as false,\n   * in order to get the right `axisProjectedValues` value.\n   */\n  drawFromXAxis: boolean = true,\n) => {\n  // get the inner width and height of the graph\n  const { width, height } = graphDimension;\n\n  // sort the data\n  const sortedData = useMemo(\n    () => {\n      const baseAxis = drawFromXAxis ? x : y;\n      const getValue = getValByScaleType(baseAxis.scale);\n      const getOriginalVal = (record: object) => getValue(record[baseAxis.field]);\n\n      return (\n        data.sort(\n          (rowA, rowB) => getOriginalVal(rowA) - getOriginalVal(rowB),\n        )\n      );\n    },\n    [data, x],\n  );\n\n  // groups the data by colors\n  const dataGroups = useMemo(\n    () => {\n      const encodings = [color].filter((encoding): encoding is Encoding => !!encoding);\n      return getDataGroupByEncodings(sortedData, encodings);\n    },\n    [color, sortedData],\n  );\n\n  // the scales and configs of the axis based on its encodings\n  const xAxis = useMemo(\n    () => {\n      const axisScale = getXAxisScale({\n        data,\n        axisLength: width,\n        encoding: x,\n      });\n\n      // update the domain if the domains of x-y scales is band-linear\n      if (x.scale === 'linear' && y.scale === 'band') {\n        const domain = getLinearDomainFromDataGroup(dataGroups, y.field, x.field);\n        axisScale.domain = domain;\n        axisScale.scale.domain(domain);\n      }\n      return axisScale;\n    },\n    [data, width, x],\n  );\n  const yAxis = useMemo(\n    () => {\n      const axisScale = getYAxisScale({\n        data,\n        axisLength: height,\n        encoding: y,\n      });\n\n      // update the domain if the domains of x-y scales is linear-band\n      if (x.scale === 'band' && y.scale === 'linear') {\n        const domain = getLinearDomainFromDataGroup(dataGroups, x.field, y.field);\n        axisScale.domain = domain;\n        axisScale.scale.domain(domain);\n      }\n      return axisScale;\n    },\n    [data, height, y],\n  );\n\n  // selectors to get the original/scaled/formatted values\n  const xSelector = useMemo(\n    () => getRecordFieldSelector(xAxis),\n    [xAxis],\n  );\n  const ySelector = useMemo(\n    () => getRecordFieldSelector(yAxis),\n    [yAxis],\n  );\n\n  // handle the colors\n  const colorScale = useMemo(\n    () => {\n      if (typeof color === 'undefined') {\n        return null;\n      }\n      return getColorScale({\n        data,\n        encoding: color,\n        colors: theme.colors,\n      });\n    },\n    [color, data, theme.colors],\n  );\n  const defaultColor = theme.colors.category[0];\n  const getColorString = useMemo(\n    () => (\n      colorScale\n      ? getRecordFieldSelector(colorScale).getScaledVal\n      : () => defaultColor\n    ),\n    [colorScale, defaultColor],\n  );\n\n  const axisProjectedValues: AxisProjectedValue[] = useMemo(\n    () => {\n      if (!drawFromXAxis) {\n        return getAxisProjectedValues(dataGroups, ySelector, xSelector, getColorString);\n      }\n      return getAxisProjectedValues(dataGroups, xSelector, ySelector, getColorString);\n    },\n    [dataGroups, xSelector, ySelector, getColorString],\n  );\n\n  return {\n    /** Array of data grouped by fields of colors  */\n    dataGroups,\n\n    /**\n     * The y-values in the `dataGroups` grouped by projected x values.\n     * -  Structure of groupedY: \"groupedY\":[ { \"index of dataGroup\": \"value\" }, ... ]\n     * @example\n     * [{\n     *  \"basePos\": 0,\n     *  \"baseStrVal\": \"0\",\n     *  \"projectedVals\": [{\"groupIdx\": 0, \"projectedStrVal\": 9, \"projectedPos\": 18, \"color\": \"#deebf7\"}],\n     *  },\n     * {\n     *  \"basePos\": 109.12812500000001,\n     *  \"baseStrVal\": \"2\",\n     *  \"projectedVals\": [{\"groupIdx\": 0, \"projectedStrVal\": 3, \"projectedPos\": 6, \"color\": \"#deebf7\"}, ...],\n     * }]\n     */\n    axisProjectedValues,\n\n    /** d3 scale functions and other related configurations computed for various encodings */\n    scalesConfig: {\n      /** scale function and configs for x-axis */\n      x: xAxis,\n\n      /** scale function and configs for y-axis */\n      y: yAxis,\n\n      /** scale function and configs for the color scale; null if there is no color encoding */\n      color: colorScale,\n    },\n\n    /** Contains functions to select values from a data row */\n    rowValSelectors: {\n      /** Functions to get value on the x-axis */\n      x: xSelector,\n\n      /** Functions to get value on the y-axis */\n      y: ySelector,\n\n      /** Functions to get colors */\n      color: {\n        /** Function to get the color string */\n        getString: getColorString,\n      },\n    },\n  };\n};\n","import React, { useContext, useMemo } from 'react';\nimport {\n  // from AxisLayer\n  AxisLayer,\n  // from Overlays\n  HeaderBox,\n  HeaderBoxProps,\n  // from common types\n  AxisScale,\n  Margin,\n  GraphDimension,\n  AxisEncoding,\n  // theme\n  ThemeContext,\n  GlobalTheme,\n  // styled-components\n  styled,\n} from '@ichef/transcharts-graph';\n\nexport interface FrameContentProps {\n  /** Width and height of the outer container including the margin */\n  outerDimension: GraphDimension;\n\n  /** Width and height of the graph to be drawed inside the SVG group */\n  graphDimension: GraphDimension;\n\n  /** Axis encoding of x-axis */\n  x: AxisEncoding;\n\n  /** Axis encoding of y-axis */\n  y: AxisEncoding;\n\n  /** Whether it is a vertical chart. True for most charts. */\n  drawFromXAxis: boolean;\n\n  /** Margin between the inner graph area and the outer svg */\n  margin: Margin;\n\n  /** It determines how the axes are drawn */\n  data: object[];\n\n  /** Should show the axis on the left or not */\n  showLeftAxis: boolean;\n\n  /** Should show the axis on the bottom or not */\n  showBottomAxis: boolean;\n\n  /** Whether to display the axes in the background or foreground of the chart */\n  axisInBackground: boolean;\n\n  scalesConfig: {\n    x: AxisScale,\n    y: AxisScale,\n  };\n\n  /** Elements to be overlayed on top of the SVG */\n  svgOverlay?: React.ReactNode;\n\n  /** Elements to be drawed inside of the SVG */\n  children: React.ReactNode;\n}\nexport interface SvgFrameProps extends FrameContentProps {\n  /** Ref to <HeaderBox> */\n  titleRef: React.RefObject<HTMLDivElement>;\n\n  /** Title of <HeaderBox> */\n  title?: HeaderBoxProps['title'];\n\n  /** Description of <HeaderBox> */\n  titleDesc?: HeaderBoxProps['desc'];\n\n  /** Text align of the header box */\n  titleAlign?: HeaderBoxProps['align'];\n}\n\nconst defaultProps = {\n  showLeftAxis: true,\n  showBottomAxis: true,\n  axisInBackground: true,\n  drawFromXAxis: true,\n};\n\nconst Wrapper = styled.div<GlobalTheme>`\n  width: 100%;\n  height: 100%;\n  position: relative;\n  color: ${({ fontColor }) => fontColor};\n`;\n\nconst FrameContent = ({\n  outerDimension,\n  graphDimension,\n  x,\n  y,\n  drawFromXAxis,\n  margin,\n  data,\n  scalesConfig,\n  showLeftAxis,\n  showBottomAxis,\n  axisInBackground,\n  svgOverlay,\n  children,\n}: FrameContentProps) => {\n  // memoize the frame to increase the performance when rendering tooltips\n  const momoizedFrame = useMemo(\n    () => {\n      const { width: outerWidth, height: outerHeight } = outerDimension;\n      const { width: graphWidth, height: graphHeight } = graphDimension;\n      const axisLayer = (\n        <AxisLayer\n          width={graphWidth}\n          height={graphHeight}\n          showLeftAxis={showLeftAxis}\n          showBottomAxis={showBottomAxis}\n          data={data}\n          x={x}\n          y={y}\n          drawFromXAxis={drawFromXAxis}\n          xAxisScale={scalesConfig.x.scale}\n          yAxisScale={scalesConfig.y.scale}\n        />\n      );\n\n      return (\n        <>\n          <svg width={outerWidth} height={outerHeight}>\n            <g transform={`translate(${margin.left}, ${margin.top})`}>\n              {axisInBackground ? (<>{axisLayer}{children}</>) : (<>{children}{axisLayer}</>)}\n            </g>\n          </svg>\n          {svgOverlay}\n        </>\n      );\n    },\n    [\n      outerDimension,\n      graphDimension,\n      x,\n      y,\n      margin,\n      data,\n      scalesConfig,\n      showLeftAxis,\n      showBottomAxis,\n      axisInBackground,\n      svgOverlay,\n      children,\n    ]\n  );\n\n  return momoizedFrame;\n};\nFrameContent.defaultProps = defaultProps;\n\n/**\n * It manages the size of the chart container, SVG, and the axes\n * that generally used across different charts.\n */\nexport const SvgWithAxisFrame = React.forwardRef<\n  HTMLDivElement,\n  JSX.LibraryManagedAttributes<typeof FrameContent, SvgFrameProps>\n>(({\n  titleRef,\n  title,\n  titleDesc,\n  titleAlign,\n  ...restProps\n}, ref) => {\n  const theme = useContext(ThemeContext);\n  const { globalStyle } = theme;\n\n  return (\n    <Wrapper\n      ref={ref}\n      {...globalStyle}\n    >\n      <FrameContent {...restProps} />\n      <HeaderBox\n        ref={titleRef}\n        title={title}\n        desc={titleDesc}\n        align={titleAlign}\n      />\n    </Wrapper>\n  );\n});\n","import React, { useContext, useMemo } from 'react';\nimport { LinePath } from '@vx/shape';\nimport {\n  // from HoverLayer\n  HoverLayer,\n  // from hooks\n  useHoverState,\n  // from TooltipLayer\n  TooltipLayer,\n  AxisProjectedValue,\n  // from Legend,\n  LegendGroup,\n  // from common types\n  FieldSelector,\n  // from themes\n  Theme,\n  ThemeContext,\n} from '@ichef/transcharts-graph';\n\nimport { useChartDimensions } from '../hooks/useChartDimensions';\nimport { useCartesianEncodings } from '../hooks/useCartesianEncodings';\nimport { SvgWithAxisFrame } from '../frames/SvgWithAxisFrame';\nimport { DEFAULT_VALS } from '../common/config';\nimport { CommonChartProps } from '../common/types';\n\n/**\n * Return the position of the hovering detection rect.\n * If the given index exceeds its bound, it will return its closest value.\n */\nfunction getXPosByIndex(arr: AxisProjectedValue[], idx: number) {\n  let arrIdx = idx < 0 ? 0 : idx;\n  if (idx >= arr.length) {\n    arrIdx = arr.length - 1;\n  }\n  return arr[arrIdx].basePos;\n}\n\nexport type LineChartProps = CommonChartProps;\n\n/** A line and a dot for the point being hovered */\nconst HoveringIndicator = ({ hovering, projectedPoints, height }: {\n  hovering: boolean,\n  projectedPoints: AxisProjectedValue,\n  height: number,\n}) => {\n  if (!hovering) {\n    return null;\n  }\n\n  const circles = projectedPoints.projectedVals.map(pointY => (\n    <circle\n      key={`c-${pointY.projectedStrVal}`}\n      cx={projectedPoints.basePos}\n      cy={pointY.projectedPos}\n      r={4.5}\n      fill={pointY.color}\n    />\n  ));\n\n  return(\n    <>\n      <line\n        x1={projectedPoints.basePos}\n        y1={0}\n        x2={projectedPoints.basePos}\n        y2={height}\n        style={{ stroke:'rgba(124, 137, 147, 0.25)', strokeWidth: 2 }}\n      />\n      {circles}\n    </>\n  );\n};\n\nconst DataLine = ({ color, xSelector, ySelector, rows }: {\n  color: string,\n  xSelector: FieldSelector,\n  ySelector: FieldSelector,\n  rows: object[],\n}) => {\n  const lineDots = rows.map((dataRow, index) => (\n    <circle\n      key={`c-${index}`}\n      cx={xSelector.getScaledVal(dataRow)}\n      cy={ySelector.getScaledVal(dataRow)}\n      r={3.5}\n      fill={color}\n    />\n  ));\n  return (\n    <>\n      {/* Draw the line */}\n      <LinePath\n        data={rows}\n        x={xSelector.getScaledVal}\n        y={ySelector.getScaledVal}\n        stroke={color}\n        strokeWidth={2}\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n      />\n\n      {/* Draw dots on the line */}\n      {lineDots}\n    </>\n  );\n};\n\nconst defaultProps = {\n  margin: DEFAULT_VALS.MARGIN,\n};\n\nexport const LineChart = ({\n  data,\n  margin,\n  x,\n  y,\n  color,\n  title,\n  titleDesc,\n  titleAlign,\n  showLeftAxis,\n  showBottomAxis,\n}: LineChartProps) => {\n  const theme = useContext<Theme>(ThemeContext);\n  const {\n    chartRef,\n    titleRef,\n    legendRef,\n    outerDimension,\n    graphDimension,\n    graphMargin,\n  } = useChartDimensions(margin, color);\n  const { width: graphWidth, height: graphHeight } = graphDimension;\n  const { clearHovering, hovering, hoveredPoint, setHoveredPosAndIndex } = useHoverState();\n  const {\n    dataGroups,\n    scalesConfig,\n    rowValSelectors,\n    axisProjectedValues,\n  } = useCartesianEncodings(graphDimension, theme, data, x, y, color);\n\n  const graphGroup = useMemo(\n    () => (\n      dataGroups.map(\n        (rows: object[], index: number) => {\n          const colorString: string = rowValSelectors.color.getString(rows[0]);\n          return (\n            <DataLine\n              key={`row-${index}`}\n              color={colorString}\n              rows={rows}\n              xSelector={rowValSelectors.x}\n              ySelector={rowValSelectors.y}\n            />\n          );\n        }\n      )\n    ),\n    [dataGroups, rowValSelectors]\n  );\n\n  const hoverDetectionComponents = useMemo(\n    () => (\n      axisProjectedValues.map(\n        (row, idx) => {\n          const rectX = (row.basePos + getXPosByIndex(axisProjectedValues, idx - 1)) / 2;\n\n          const rectWidth = (\n            (row.basePos + getXPosByIndex(axisProjectedValues, idx + 1)) / 2\n          ) - rectX;\n\n          return (\n            <rect\n              // #TODO: use unique keys rather than array index\n              key={`colli-${idx}`}\n              x={rectX}\n              y={0}\n              width={rectWidth}\n              height={graphHeight}\n              opacity={0}\n            />\n          );\n        }\n      )\n    ),\n    [axisProjectedValues, graphHeight]\n  );\n\n  return (\n    <SvgWithAxisFrame\n      ref={chartRef}\n      titleRef={titleRef}\n      title={title}\n      titleDesc={titleDesc}\n      titleAlign={titleAlign}\n      outerDimension={outerDimension}\n      graphDimension={graphDimension}\n      showLeftAxis={showLeftAxis}\n      showBottomAxis={showBottomAxis}\n      x={x}\n      y={y}\n      margin={graphMargin}\n      data={data}\n      scalesConfig={scalesConfig}\n      svgOverlay={\n        <>\n          {/* Draw the tooltip */}\n          <TooltipLayer\n            hovering={hovering}\n            hoveredPoint={hoveredPoint}\n            axisProjectedValues={axisProjectedValues}\n            graphWidth={graphWidth}\n            graphHeight={graphHeight}\n            margin={graphMargin}\n          />\n          {/* Draw the legned */}\n          <LegendGroup\n            color={color && {\n              ...color,\n              ...scalesConfig.color!,\n            }}\n            ref={legendRef}\n          />\n        </>\n      }\n    >\n      {graphGroup}\n      <HoveringIndicator\n        hovering={hovering}\n        projectedPoints={axisProjectedValues[hoveredPoint.index]}\n        height={graphHeight}\n      />\n\n      {/* Areas which are used to detect mouse or touch interactions */}\n      <HoverLayer\n        setHoveredPosAndIndex={setHoveredPosAndIndex}\n        clearHovering={clearHovering}\n        hoverDetectionComponents={hoverDetectionComponents}\n      />\n    </SvgWithAxisFrame>\n  );\n};\nLineChart.defaultProps = defaultProps;\n","export function getAccumXCalculator(baseX: number) {\n  // calculate the accumulated x position of certain points\n  const positiveX = {};\n  const nonPositiveX = {};\n\n  return (yPos: number, scaledX: number) => {\n    if (scaledX < 0) {\n      if (!nonPositiveX[yPos]) {\n        nonPositiveX[yPos] = baseX;\n      }\n      nonPositiveX[yPos] += scaledX;\n      return nonPositiveX[yPos];\n    }\n\n    // scaledX >= 0\n    const xPos = !positiveX[yPos] ? baseX : positiveX[yPos];\n    positiveX[yPos] = xPos + scaledX;\n    return xPos;\n  };\n}\n\nexport function getAccumYCalculator(baseY: number) {\n  // calculate the accumulated y position of certain points\n  const positiveY = {};\n  const nonPositiveY = {};\n\n  return (xPos: number, scaledY: number) => {\n    if (scaledY >= 0) {\n      if (!positiveY[xPos]) {\n        positiveY[xPos] = baseY;\n      }\n      positiveY[xPos] -= scaledY;\n      return positiveY[xPos];\n    }\n\n    // scaledY < 0\n    const yPos = !nonPositiveY[xPos] ? baseY : nonPositiveY[xPos];\n    nonPositiveY[xPos] = yPos - scaledY;\n    return yPos;\n  };\n}\n","import React, { useContext, useMemo, useCallback } from 'react';\nimport { ScaleBand, ScaleLinear } from 'd3-scale';\nimport {\n  // from HoverLayer\n  HoverLayer,\n  // from hooks\n  useHoverState,\n  // from TooltipLayer\n  TooltipLayer,\n  // from Legend,\n  LegendGroup,\n  // from common types\n  AxisEncoding,\n  // from themes\n  Theme,\n  ThemeContext,\n} from '@ichef/transcharts-graph';\n\nimport {\n  getAccumXCalculator,\n  getAccumYCalculator,\n} from '../utils/getBarChartPos';\nimport { useChartDimensions } from '../hooks/useChartDimensions';\nimport { useCartesianEncodings } from '../hooks/useCartesianEncodings';\nimport { SvgWithAxisFrame } from '../frames/SvgWithAxisFrame';\nimport { DEFAULT_VALS } from '../common/config';\nimport { CommonChartProps } from '../common/types';\n\n/** A line and a dot for the point being hovered */\nconst HoveringIndicator = ({ hovering, x, y, width, height }: {\n  hovering: boolean,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n}) => {\n  if (!hovering) {\n    return null;\n  }\n\n  return(\n    <rect\n      x={x}\n      y={y}\n      width={width}\n      height={height}\n      opacity={0.5}\n      fill=\"rgba(124, 137, 147, 0.25)\"\n    />\n  );\n};\n\nexport interface BarChartProps extends CommonChartProps {\n  /** Ratio of the paddings between bars */\n  paddingInner: number;\n}\n\nconst defaultProps = {\n  margin: DEFAULT_VALS.MARGIN,\n  paddingInner: 0.1,\n};\n\nexport const BarChart = ({\n  data,\n  // FIXME: remove the default margin after fixing the defaultProps of`<SvgWithAxisFrame>`\n  margin = {\n    top: 20,\n    right: 20,\n    bottom: 30,\n    left: 60,\n  },\n  x,\n  y,\n  color,\n  title,\n  titleDesc,\n  titleAlign,\n  showLeftAxis,\n  showBottomAxis,\n  paddingInner = 0.1,\n}: BarChartProps) => {\n  const theme = useContext<Theme>(ThemeContext);\n  const {\n    chartRef,\n    titleRef,\n    legendRef,\n    outerDimension,\n    graphDimension,\n    graphMargin,\n  } = useChartDimensions(margin, color);\n  const { width: graphWidth, height: graphHeight } = graphDimension;\n\n  /**\n   * Whether the graph should be drawn from the x-axis.\n   * False if it should be drawn from the y-axis.\n   */\n  const drawFromXAxis = useMemo(\n    () => {\n      return x.type !== 'quantitative';\n    },\n    [x, y],\n  );\n\n  // assign the scale according to the data type\n  const xEncoding: AxisEncoding = { ...x, scale: 'band' };\n  const yEncoding: AxisEncoding = { ...y, scale: 'linear' };\n  if (drawFromXAxis) {\n    xEncoding.scaleConfig = { paddingInner };\n  } else {\n    xEncoding.scale = 'linear';\n    yEncoding.scale = 'band';\n    yEncoding.scaleConfig = { paddingInner };\n  }\n\n  const {\n    dataGroups,\n    scalesConfig,\n    rowValSelectors,\n    axisProjectedValues,\n  } = useCartesianEncodings(\n    graphDimension,\n    theme,\n    data,\n    xEncoding,\n    yEncoding,\n    color,\n    drawFromXAxis,\n  );\n  const { clearHovering, hovering, hoveredPoint, setHoveredPosAndIndex } = useHoverState();\n\n  const bandScale = scalesConfig[drawFromXAxis ? 'x' : 'y'].scale as ScaleBand<any>;\n  const linearScale = scalesConfig[drawFromXAxis ? 'y' : 'x'].scale as ScaleLinear<any, any>;\n  const bandWidth = useMemo(\n    () => {\n      return bandScale.bandwidth();\n    },\n    [bandScale]\n  );\n  const xOffset = useMemo(\n    () => {\n      return drawFromXAxis ? bandWidth / 2 : 0;\n    },\n    [drawFromXAxis, bandWidth]\n  );\n\n  /**\n   * Returns the size and position of the hovering detection rectangle\n   * or hovering highlight rectangle\n   */\n  const getHoveringRectPos = useCallback(\n    (idx: number) => {\n      const paddingVal = bandWidth * paddingInner;\n\n      const basePos = idx === 0\n        ? 0\n        : axisProjectedValues[idx].basePos - paddingVal / 2;\n      const width = idx === 0 || idx === data.length - 1\n            ? bandWidth + paddingVal / 2\n            : bandWidth + paddingVal;\n\n      // transposed (horizontal) graph\n      if (!drawFromXAxis) {\n        return {\n          width: graphWidth,\n          height: width,\n          x: 0,\n          y: basePos,\n        };\n      }\n\n      // vertical graph\n      return {\n        width,\n        height: graphHeight,\n        x: basePos,\n        y: 0,\n      };\n    },\n    [bandWidth, paddingInner, graphWidth, graphHeight],\n  );\n\n  const hoverDetectionComponents = useMemo(\n    () => (\n      axisProjectedValues.map(\n        (row, idx) => {\n          return (\n            <rect\n              // #TODO: use unique keys rather than array index\n              key={`colli-${idx}`}\n              opacity={0}\n              {...{ ...getHoveringRectPos(idx) }}\n            />\n          );\n        }\n      )\n    ),\n    [axisProjectedValues, graphHeight, bandWidth, getHoveringRectPos]\n  );\n\n  /**\n   * Draw the bars of the bar chart\n   */\n  const graphGroup = useMemo(\n    () => {\n      const baseVal = linearScale(0);\n      const accumCalculator = drawFromXAxis ? getAccumYCalculator : getAccumXCalculator;\n      const getAccumVal = accumCalculator(baseVal);\n\n      return dataGroups.map(\n        (rows: object[], groupIdx: number) => {\n          return rows.map((row: object, rowIdx: number) => {\n            const colorString: string = rowValSelectors.color.getString(rows[0]);\n            const scaledX = rowValSelectors.x.getScaledVal(row);\n            const scaledY = rowValSelectors.y.getScaledVal(row);\n\n            let barPos;\n            if (drawFromXAxis) {\n              const height = scaledY >= 0\n                ? baseVal - scaledY\n                : baseVal - graphHeight - scaledY;\n\n              barPos = {\n                x: scaledX,\n                y: getAccumVal(scaledX, height),\n                width: bandWidth,\n                height: Math.abs(height),\n              };\n            } else {\n              // transposed (horizontal) graph\n              const diffFromBase = scaledX - baseVal;\n\n              barPos = {\n                x: getAccumVal(scaledY, diffFromBase),\n                y: scaledY,\n                width: Math.abs(diffFromBase),\n                height: bandWidth,\n              };\n            }\n\n            return (\n              <rect\n                {...barPos}\n                key={`bar-${rowIdx}`}\n                fill={colorString}\n              />\n            );\n          });\n        }\n      );\n    },\n    [dataGroups, scalesConfig, rowValSelectors],\n  );\n\n  return (\n    <SvgWithAxisFrame\n      ref={chartRef}\n      titleRef={titleRef}\n      title={title}\n      titleDesc={titleDesc}\n      titleAlign={titleAlign}\n      outerDimension={outerDimension}\n      graphDimension={graphDimension}\n      showLeftAxis={showLeftAxis}\n      showBottomAxis={showBottomAxis}\n      x={x}\n      y={y}\n      drawFromXAxis={drawFromXAxis}\n      // put the axes on top of the bars\n      axisInBackground={false}\n      margin={graphMargin}\n      data={data}\n      scalesConfig={scalesConfig}\n      svgOverlay={\n        <>\n          {/* Draw the tooltip */}\n          <TooltipLayer\n            hovering={hovering}\n            hoveredPoint={hoveredPoint}\n            axisProjectedValues={axisProjectedValues}\n            graphWidth={graphWidth}\n            graphHeight={graphHeight}\n            margin={margin}\n            drawFromXAxis={drawFromXAxis}\n            xOffset={xOffset}\n          />\n          {/* Draw the legend */}\n          <LegendGroup\n            color={color && {\n              ...color,\n              ...scalesConfig.color!,\n            }}\n            ref={legendRef}\n          />\n        </>\n      }\n    >\n      {graphGroup}\n      <HoveringIndicator\n        hovering={hovering}\n        {...{ ...getHoveringRectPos(hoveredPoint.index) }}\n      />\n\n      {/* Areas which are used to detect mouse or touch interactions */}\n      <HoverLayer\n        setHoveredPosAndIndex={setHoveredPosAndIndex}\n        clearHovering={clearHovering}\n        hoverDetectionComponents={hoverDetectionComponents}\n      />\n    </SvgWithAxisFrame>\n  );\n};\nBarChart.defaultProps = defaultProps;\n","export * from './common/config';\nexport * from './hooks/useChartDimensions';\nexport * from './hooks/useCartesianEncodings';\nexport * from './line/LineChart';\nexport * from './bar/BarChart';\nexport * from './frames/SvgWithAxisFrame';\nexport * from './utils/getInnerGraphDimensionAndMargin';\n"],"sourceRoot":""}